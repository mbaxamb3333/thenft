{"ast":null,"code":"'use strict';\n/**\n * Dependencies\n */\n\nconst toCamelCase = require('../helpers/to-camel-case');\n\nconst toSnakeCase = require('../helpers/to-snake-case');\n\nconst deepClone = require('../helpers/deep-clone');\n\nconst fs = require('fs');\n\nconst path = require('path');\n/**\n * Attachment class\n */\n\n\nclass Attachment {\n  /**\n   * Constructor\n   */\n  constructor(data) {\n    //Create from data\n    if (data) {\n      this.fromData(data);\n    }\n  }\n  /**\n   * From data\n   */\n\n\n  fromData(data) {\n    //Expecting object\n    if (typeof data !== 'object') {\n      throw new Error('Expecting object for Mail data');\n    } //Convert to camel case to make it workable, making a copy to prevent\n    //changes to the original objects\n\n\n    data = deepClone(data);\n    data = toCamelCase(data); //Extract properties from data\n\n    const {\n      content,\n      filename,\n      type,\n      disposition,\n      contentId,\n      filePath\n    } = data;\n\n    if (typeof content !== 'undefined' && typeof filePath !== 'undefined') {\n      throw new Error(\"The props 'content' and 'filePath' cannot be used together.\");\n    } //Set data\n\n\n    this.setFilename(filename);\n    this.setType(type);\n    this.setDisposition(disposition);\n    this.setContentId(contentId);\n    this.setContent(filePath ? this.readFile(filePath) : content);\n  }\n  /**\n   * Read a file and return its content as base64\n   */\n\n\n  readFile(filePath) {\n    return fs.readFileSync(path.resolve(filePath));\n  }\n  /**\n   * Set content\n   */\n\n\n  setContent(content) {\n    //Duck type check toString on content if it's a Buffer as that's the method that will be called.\n    if (typeof content === 'string') {\n      this.content = content;\n      return;\n    } else if (content instanceof Buffer && content.toString !== undefined) {\n      this.content = content.toString();\n\n      if (this.disposition === 'attachment') {\n        this.content = content.toString('base64');\n      }\n\n      return;\n    }\n\n    throw new Error('`content` expected to be either Buffer or string');\n  }\n  /**\n   * Set content\n   */\n\n\n  setFileContent(content) {\n    if (content instanceof Buffer && content.toString !== undefined) {\n      this.content = content.toString('base64');\n      return;\n    }\n\n    throw new Error('`content` expected to be Buffer');\n  }\n  /**\n   * Set filename\n   */\n\n\n  setFilename(filename) {\n    if (typeof filename === 'undefined') {\n      return;\n    }\n\n    if (filename && typeof filename !== 'string') {\n      throw new Error('String expected for `filename`');\n    }\n\n    this.filename = filename;\n  }\n  /**\n   * Set type\n   */\n\n\n  setType(type) {\n    if (typeof type === 'undefined') {\n      return;\n    }\n\n    if (typeof type !== 'string') {\n      throw new Error('String expected for `type`');\n    }\n\n    this.type = type;\n  }\n  /**\n   * Set disposition\n   */\n\n\n  setDisposition(disposition) {\n    if (typeof disposition === 'undefined') {\n      return;\n    }\n\n    if (typeof disposition !== 'string') {\n      throw new Error('String expected for `disposition`');\n    }\n\n    this.disposition = disposition;\n  }\n  /**\n   * Set content ID\n   */\n\n\n  setContentId(contentId) {\n    if (typeof contentId === 'undefined') {\n      return;\n    }\n\n    if (typeof contentId !== 'string') {\n      throw new Error('String expected for `contentId`');\n    }\n\n    this.contentId = contentId;\n  }\n  /**\n   * To JSON\n   */\n\n\n  toJSON() {\n    //Extract properties from self\n    const {\n      content,\n      filename,\n      type,\n      disposition,\n      contentId\n    } = this; //Initialize with mandatory properties\n\n    const json = {\n      content,\n      filename\n    }; //Add whatever else we have\n\n    if (typeof type !== 'undefined') {\n      json.type = type;\n    }\n\n    if (typeof disposition !== 'undefined') {\n      json.disposition = disposition;\n    }\n\n    if (typeof contentId !== 'undefined') {\n      json.contentId = contentId;\n    } //Return\n\n\n    return toSnakeCase(json);\n  }\n\n} //Export class\n\n\nmodule.exports = Attachment;","map":{"version":3,"sources":["/Users/mihaibadea/thenft/node_modules/@sendgrid/helpers/classes/attachment.js"],"names":["toCamelCase","require","toSnakeCase","deepClone","fs","path","Attachment","constructor","data","fromData","Error","content","filename","type","disposition","contentId","filePath","setFilename","setType","setDisposition","setContentId","setContent","readFile","readFileSync","resolve","Buffer","toString","undefined","setFileContent","toJSON","json","module","exports"],"mappings":"AAAA;AAEA;AACA;AACA;;AACA,MAAMA,WAAW,GAAGC,OAAO,CAAC,0BAAD,CAA3B;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,0BAAD,CAA3B;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,uBAAD,CAAzB;;AACA,MAAMG,EAAE,GAAGH,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMI,IAAI,GAAGJ,OAAO,CAAC,MAAD,CAApB;AAEA;AACA;AACA;;;AACA,MAAMK,UAAN,CAAiB;AAEf;AACF;AACA;AACEC,EAAAA,WAAW,CAACC,IAAD,EAAO;AAEhB;AACA,QAAIA,IAAJ,EAAU;AACR,WAAKC,QAAL,CAAcD,IAAd;AACD;AACF;AAED;AACF;AACA;;;AACEC,EAAAA,QAAQ,CAACD,IAAD,EAAO;AAEb;AACA,QAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,YAAM,IAAIE,KAAJ,CAAU,gCAAV,CAAN;AACD,KALY,CAOb;AACA;;;AACAF,IAAAA,IAAI,GAAGL,SAAS,CAACK,IAAD,CAAhB;AACAA,IAAAA,IAAI,GAAGR,WAAW,CAACQ,IAAD,CAAlB,CAVa,CAYb;;AACA,UAAM;AACJG,MAAAA,OADI;AAEJC,MAAAA,QAFI;AAGJC,MAAAA,IAHI;AAIJC,MAAAA,WAJI;AAKJC,MAAAA,SALI;AAMJC,MAAAA;AANI,QAOFR,IAPJ;;AASA,QAAK,OAAOG,OAAP,KAAmB,WAApB,IAAqC,OAAOK,QAAP,KAAoB,WAA7D,EAA2E;AACzE,YAAM,IAAIN,KAAJ,CACJ,6DADI,CAAN;AAGD,KA1BY,CA4Bb;;;AACA,SAAKO,WAAL,CAAiBL,QAAjB;AACA,SAAKM,OAAL,CAAaL,IAAb;AACA,SAAKM,cAAL,CAAoBL,WAApB;AACA,SAAKM,YAAL,CAAkBL,SAAlB;AACA,SAAKM,UAAL,CAAgBL,QAAQ,GAAG,KAAKM,QAAL,CAAcN,QAAd,CAAH,GAA6BL,OAArD;AACD;AAED;AACF;AACA;;;AACEW,EAAAA,QAAQ,CAACN,QAAD,EAAW;AACjB,WAAOZ,EAAE,CAACmB,YAAH,CAAgBlB,IAAI,CAACmB,OAAL,CAAaR,QAAb,CAAhB,CAAP;AACD;AAED;AACF;AACA;;;AACEK,EAAAA,UAAU,CAACV,OAAD,EAAU;AAClB;AACA,QAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,WAAKA,OAAL,GAAeA,OAAf;AACA;AACD,KAHD,MAGO,IAAIA,OAAO,YAAYc,MAAnB,IAA6Bd,OAAO,CAACe,QAAR,KAAqBC,SAAtD,EAAiE;AACtE,WAAKhB,OAAL,GAAeA,OAAO,CAACe,QAAR,EAAf;;AAEA,UAAI,KAAKZ,WAAL,KAAqB,YAAzB,EAAuC;AACrC,aAAKH,OAAL,GAAeA,OAAO,CAACe,QAAR,CAAiB,QAAjB,CAAf;AACD;;AAED;AACD;;AAED,UAAM,IAAIhB,KAAJ,CAAU,kDAAV,CAAN;AACD;AAED;AACF;AACA;;;AACEkB,EAAAA,cAAc,CAACjB,OAAD,EAAU;AACtB,QAAIA,OAAO,YAAYc,MAAnB,IAA6Bd,OAAO,CAACe,QAAR,KAAqBC,SAAtD,EAAiE;AAC/D,WAAKhB,OAAL,GAAeA,OAAO,CAACe,QAAR,CAAiB,QAAjB,CAAf;AACA;AACD;;AAED,UAAM,IAAIhB,KAAJ,CAAU,iCAAV,CAAN;AACD;AAED;AACF;AACA;;;AACEO,EAAAA,WAAW,CAACL,QAAD,EAAW;AACpB,QAAI,OAAOA,QAAP,KAAoB,WAAxB,EAAqC;AACnC;AACD;;AACD,QAAIA,QAAQ,IAAI,OAAOA,QAAP,KAAoB,QAApC,EAA8C;AAC5C,YAAM,IAAIF,KAAJ,CAAU,gCAAV,CAAN;AACD;;AACD,SAAKE,QAAL,GAAgBA,QAAhB;AACD;AAED;AACF;AACA;;;AACEM,EAAAA,OAAO,CAACL,IAAD,EAAO;AACZ,QAAI,OAAOA,IAAP,KAAgB,WAApB,EAAiC;AAC/B;AACD;;AACD,QAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,YAAM,IAAIH,KAAJ,CAAU,4BAAV,CAAN;AACD;;AACD,SAAKG,IAAL,GAAYA,IAAZ;AACD;AAED;AACF;AACA;;;AACEM,EAAAA,cAAc,CAACL,WAAD,EAAc;AAC1B,QAAI,OAAOA,WAAP,KAAuB,WAA3B,EAAwC;AACtC;AACD;;AACD,QAAI,OAAOA,WAAP,KAAuB,QAA3B,EAAqC;AACnC,YAAM,IAAIJ,KAAJ,CAAU,mCAAV,CAAN;AACD;;AACD,SAAKI,WAAL,GAAmBA,WAAnB;AACD;AAED;AACF;AACA;;;AACEM,EAAAA,YAAY,CAACL,SAAD,EAAY;AACtB,QAAI,OAAOA,SAAP,KAAqB,WAAzB,EAAsC;AACpC;AACD;;AACD,QAAI,OAAOA,SAAP,KAAqB,QAAzB,EAAmC;AACjC,YAAM,IAAIL,KAAJ,CAAU,iCAAV,CAAN;AACD;;AACD,SAAKK,SAAL,GAAiBA,SAAjB;AACD;AAED;AACF;AACA;;;AACEc,EAAAA,MAAM,GAAG;AAEP;AACA,UAAM;AAAClB,MAAAA,OAAD;AAAUC,MAAAA,QAAV;AAAoBC,MAAAA,IAApB;AAA0BC,MAAAA,WAA1B;AAAuCC,MAAAA;AAAvC,QAAoD,IAA1D,CAHO,CAKP;;AACA,UAAMe,IAAI,GAAG;AAACnB,MAAAA,OAAD;AAAUC,MAAAA;AAAV,KAAb,CANO,CAQP;;AACA,QAAI,OAAOC,IAAP,KAAgB,WAApB,EAAiC;AAC/BiB,MAAAA,IAAI,CAACjB,IAAL,GAAYA,IAAZ;AACD;;AACD,QAAI,OAAOC,WAAP,KAAuB,WAA3B,EAAwC;AACtCgB,MAAAA,IAAI,CAAChB,WAAL,GAAmBA,WAAnB;AACD;;AACD,QAAI,OAAOC,SAAP,KAAqB,WAAzB,EAAsC;AACpCe,MAAAA,IAAI,CAACf,SAAL,GAAiBA,SAAjB;AACD,KAjBM,CAmBP;;;AACA,WAAOb,WAAW,CAAC4B,IAAD,CAAlB;AACD;;AAxKc,C,CA2KjB;;;AACAC,MAAM,CAACC,OAAP,GAAiB1B,UAAjB","sourcesContent":["'use strict';\n\n/**\n * Dependencies\n */\nconst toCamelCase = require('../helpers/to-camel-case');\nconst toSnakeCase = require('../helpers/to-snake-case');\nconst deepClone = require('../helpers/deep-clone');\nconst fs = require('fs');\nconst path = require('path');\n\n/**\n * Attachment class\n */\nclass Attachment {\n\n  /**\n   * Constructor\n   */\n  constructor(data) {\n\n    //Create from data\n    if (data) {\n      this.fromData(data);\n    }\n  }\n\n  /**\n   * From data\n   */\n  fromData(data) {\n\n    //Expecting object\n    if (typeof data !== 'object') {\n      throw new Error('Expecting object for Mail data');\n    }\n\n    //Convert to camel case to make it workable, making a copy to prevent\n    //changes to the original objects\n    data = deepClone(data);\n    data = toCamelCase(data);\n\n    //Extract properties from data\n    const {\n      content,\n      filename,\n      type,\n      disposition,\n      contentId,\n      filePath,\n    } = data;\n\n    if ((typeof content !== 'undefined') && (typeof filePath !== 'undefined')) {\n      throw new Error(\n        \"The props 'content' and 'filePath' cannot be used together.\"\n      );\n    }\n\n    //Set data\n    this.setFilename(filename);\n    this.setType(type);\n    this.setDisposition(disposition);\n    this.setContentId(contentId);\n    this.setContent(filePath ? this.readFile(filePath) : content);\n  }\n\n  /**\n   * Read a file and return its content as base64\n   */\n  readFile(filePath) {\n    return fs.readFileSync(path.resolve(filePath));\n  }\n\n  /**\n   * Set content\n   */\n  setContent(content) {\n    //Duck type check toString on content if it's a Buffer as that's the method that will be called.\n    if (typeof content === 'string') {\n      this.content = content;\n      return;\n    } else if (content instanceof Buffer && content.toString !== undefined) {\n      this.content = content.toString();\n\n      if (this.disposition === 'attachment') {\n        this.content = content.toString('base64');\n      }\n\n      return;\n    }\n\n    throw new Error('`content` expected to be either Buffer or string');\n  }\n\n  /**\n   * Set content\n   */\n  setFileContent(content) {\n    if (content instanceof Buffer && content.toString !== undefined) {\n      this.content = content.toString('base64');\n      return;\n    }\n\n    throw new Error('`content` expected to be Buffer');\n  }\n\n  /**\n   * Set filename\n   */\n  setFilename(filename) {\n    if (typeof filename === 'undefined') {\n      return;\n    }\n    if (filename && typeof filename !== 'string') {\n      throw new Error('String expected for `filename`');\n    }\n    this.filename = filename;\n  }\n\n  /**\n   * Set type\n   */\n  setType(type) {\n    if (typeof type === 'undefined') {\n      return;\n    }\n    if (typeof type !== 'string') {\n      throw new Error('String expected for `type`');\n    }\n    this.type = type;\n  }\n\n  /**\n   * Set disposition\n   */\n  setDisposition(disposition) {\n    if (typeof disposition === 'undefined') {\n      return;\n    }\n    if (typeof disposition !== 'string') {\n      throw new Error('String expected for `disposition`');\n    }\n    this.disposition = disposition;\n  }\n\n  /**\n   * Set content ID\n   */\n  setContentId(contentId) {\n    if (typeof contentId === 'undefined') {\n      return;\n    }\n    if (typeof contentId !== 'string') {\n      throw new Error('String expected for `contentId`');\n    }\n    this.contentId = contentId;\n  }\n\n  /**\n   * To JSON\n   */\n  toJSON() {\n\n    //Extract properties from self\n    const {content, filename, type, disposition, contentId} = this;\n\n    //Initialize with mandatory properties\n    const json = {content, filename};\n\n    //Add whatever else we have\n    if (typeof type !== 'undefined') {\n      json.type = type;\n    }\n    if (typeof disposition !== 'undefined') {\n      json.disposition = disposition;\n    }\n    if (typeof contentId !== 'undefined') {\n      json.contentId = contentId;\n    }\n\n    //Return\n    return toSnakeCase(json);\n  }\n}\n\n//Export class\nmodule.exports = Attachment;\n"]},"metadata":{},"sourceType":"script"}